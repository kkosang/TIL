## <em>추상자료형(ADT)</em>

- 추상자료형(abstract data type,ADT)
  - 데이터구조의 추상형
- ADT는 다음을 명세해야한다
  - 저장된 데이터
  - 데이터에 대한 작업들
  - 작업중 발생 가능한 에러 상황들

## <em>리스트 ADT</em>

- 연속적인 임의 개체들을 모델링
- 원소(element)에 대한 접근 도구
  - 순위(rank)

## <em>리스트 ADT method</em>

- 원소는 순위, 즉 그 원소의 앞의 원소 개수를 특정함으로써 원소에 접근가능
- 일반 메소드
  - boolean isEmpty()
  - integer size()
  - iterator elements()
- 접근 메소드
  - element get(r)
- 갱신 메소드
  - element set(r,e)
  - add(r,e)
    - addFirst(e)
    - addLast(e)
  - element remove(r)
    - removeFirst()
    - removeLast()

## <em>예외</em>

- 실행 불가능한 작업 때문에 예외를 발령한다(throw)
- 발령 가능한 예외들
  - invalidRankException()
  - fullListException()
  - emptyListException()

## <em>배열 초기화</em>

- 초기에는 아무 원소도 없음
- O(1) 시간 소요

```
    Alg initialize()
        input array V, integer N, n
        output an empty array V of size n
    1. n <- 0
    2. return
```

## <em>배열 순회</em>

- 작업 traverse는 array의 모든 원소를 방문
- O(n)

```
    Alg traverse()
        input array V, integer N,n
        output none
    1. for r <- 0 to n-1
        visit(V[r])
    2. return
```

## <em>배열 삽입</em>

- add(r,e)에서는 r 순위로 새 원소 e가 들어갈 자리를 만들기 위해 V[n-1]부터 V[r]까지 n-r개의 원소들을 순방향(shift forward)으로 이동
- 최악의 경우(r=0)
  - O(n)

```
    Alg add(r,e)
        input array V, integer N, n, rank r, element e
        output none
    1. if(n = N) // 배열의 원소가 전부 있을경우
        fullListException()
    2. if((r<0) || (r>n)) // 삽입 위치가 0보다 작거나 n보다 큰경우
        invalidRankException()
    3. for i<-n-1 down to r
        V[i+1] <- V[i]
    4. V[r] <- e
    5. n <- n+1
    6. return
```

## <em>배열 삭제</em>

- remove(r)에서는, 삭제된 원소에 의해 빈자리를 채우기 위해 V[r+1]부터 V[n-1]까지 n-r-1개의 원소들을 역방향(shift backward)으로 이동
- 최악의 경우(r=0)
  - O(n)

```
    Alg remove(r)
        input array V, integer N, n, rank r
        output element e
    1. if((r<0) || (r>n-1))
        invalidRankException()
    2. e <- V[r]
    3. for i <- r+1 to n-1
        V[i-1] <- V[i]
    4. n <- n-1
    5. return e
```

## <em>연결리스트를 이용하여 ADT 구현</em>

- 단일연결리스트 또는 , 이중연결리스트를 사용

## <em>단일연결리스트</em>

- singly linked list
  - 연속 노드로 구성된 구체적인 데이터구조
  - 현재 가리키고 있는 노드 앞의 정보를 가리키기 어려움(데이터 삭제시 불편)
- 각 노드의 저장 내용
  - 원소(element)
  - 다음 노드를 가리키는 링크(link)

## <em>이중연결리스트</em>

- doubly linked list
  - 리스트 ADT를 자연스럽게 구현가능
  - 접근성 및 조작성이 좋음
- 각 노드의 필드
  - 원소
  - 이전 노드를 가리키는 링크
  - 다음 노드를 가리키는 링크
- 특별 헤더 및 트레일러 노드

## <em>이중연결리스트를 이용한 구현</em>

- get(r),set(r)구현
  - O(n)시간에 지정된 순위 r의 원소를 반환 또는 저장
- 연결리스트에서 순위는 1에서 출발로 전제

```
  Alg get(r)
    input a doubly linked list with header H and trailer T, rank r
    output element

  1. if((r<1)||(r>n))
        invalidRankException()
  2. p <- H
  3. for i <- 1 to r
        p <- p.next
  4. return p.elem
```

```
  Alg set(r,e)
    input a doubly linked list with header H and trailer T, rank r, element e
    output element

  1. if((r<1)||(r>n))
        invalidRankException()
  2. p<-H
  3. for i<- 1 to r
        p<-p.next
  4. p.elem <- e
  5. return e
```

- header와 trailer는 직접 사용하지 않고 동일한 포인터를 만들어서 사용함

## <em>초기화</em>

- 초기에는 아무 노드도 없다
- O(1) 시간소요

```
  Alg initialize()
    input none
    output an empty doubly linked list with header  H and trailer T
  1. H <- getnode() // malloc한 주소값 대입
  2. T <- getnode()
  3. H.next <- T
  4. T.prev <- H
  5. n <- 0       {optional}
  6. return
```

## <em>순회</em>

- 연결리스트의 모든 원소들을 방문
- O(n) 시간소요

```
  Alg traverse()
    input a doubly linked list with header H and trailer T
    output none
  1. p <- H.next
  2. while( p =/ T) // trailer를 만날때 까지
      visit(p.elem)
      p <- p.next
  3. return
```

## <em>삽입</em>

- 이중연결리스트의 지정된 순위 r에 원소 e 삽입
- O(n) 시간소요
- add(r,X) // r =3

```
  Alg add(3,X)
    input a doubly linked list with header H and trailer T, rank r, element e
    output none
  1. if((r<1) || (r>n))
      invalidRankException()
  2. p <- H
  3. for i <- 1 to r // r = 3
        p <- p.next
  4. addNodeBefore(p,e)
  5. n <- n+1         {optional}
  6. return

  Alg addNodeBefore(p,e)
    input a doubly linked list with header H and trailer T, node p, element e
  1. q <- getnode()
  2. q.element <- e  // e = x
  3. q.prev <- p.prev // 삽입하려는 노드의 prev, next먼저 연결
  4. q.next <- p
  5. (p.prev).next <- q
  6. p.prev <- q
  7. return
```

## <em>삭제</em>

- 이중연결리스트의 지정된 순위 r에 원소 e 삭제
- O(n) 시간소요
- remove(r) // r=3

```
  Alg remove(r)
    input a doubly linked list with header H and trailer T, rank r
    output element
  1. if((r<1) || (r>n))
        invalidRankException()
  2. p <- H
  3. for i <- 1 to r
        p<- p.next
  4. e <- removeNode(p)
  5. n <- n-1     {optional}
  6. return e

  Alg removeNode(p)
    input a doubly linked list with header H and trailer T, node p
    output element
  1. e <- p.elem
  2. (p.prev).next <- p.next
  3. (p.next).prev <- p.prev
  4. putnode(p)     {reuse}
  5. return e
```

## <em>단일연결리스트 삽입삭제</em>

- add(), remove()할 이전 노드 pprev를 따로 저장해야 함

## <em> 성능 </em>

- 이중연결리스트를 이용한 리스트ADT를 구현한 경우
  - 연결리스트의 각 원소에 사용되는 기억장소 O(1)
  - n개의 원소로 구성된 연결리스트에 의해 사용되는 기억장소 O(n)
  - size, isEmpty O(1)
  - get,set,add,remove O(n)
  - addFirst, addLast, removeFirst, removeLast O(1)

## <em> 성능요약 </em>

| 작업                 | 배열 | 연결리스트 |
| -------------------- | :--: | ---------: |
| size, isEmpty        |  1   |          1 |
| get,set              |  1   |          n |
| add,remove           |  n   |          n |
| addFirst,removeFirst |  n   |          1 |
| addLast,removeLast   |  1   |          1 |

- Header와 trailer가 있기 때문에 1이 나올 수 있음

## <em> 리스트 확장: 그룹과 공유 </em>

- 리스트 ADT를 확장하여 설계 가능한 고차원의 개념들을 연구
- 대상 개념
  - 그룹 (grouping)
  - 공유 (sharing)

## <em> 그룹 </em>

- 개념
  - 데이터원소들이 각각 상이한 그룹(카테고리)에 속함
- 전제
  - 각 그룹의 크기는 다양함

## <em>설계 방안</em>

- 레코드(구조체)의 리스트를 사용
  - 배열을 이용한 구현
  - 연결리스트를 이용한 구현
- 부리스트(sublist)들의 리스트 사용
  - 2D 배열 이용
  - 연결리스트의 배열 이용

## <em>설계 방안: 레코드의 리스트 사용</em>

- 그룹을 표현하기 위해, elem 및 group 필드로 구성된 레코드의 리스트를 사용
- 장점 : 단순
- 단점 : 특정그룹에 관한 작업을 위해서는 전체 레코드를 순회
  - O(n) 시간소요, n은 총 레코드 개수

## <em>설계 방안: 배열 이용</em>

- 리스트를 elem 및 group 필드로 구성된 레코드의 1D 배열을 이용하여 구현
- 장점 : 기억장소 낭비 없음

<em>초기화</em>

- 초기에는 각 그룹에 아무 레코드도 없다

```
  Alg initGroup()
    input array V, integer N, n
    output an empty array V of size n

  1. n <- 0
  2. return
```

<em>순회</em>

- 지정된 그룹의 모든 멤버들을 방문

```
  Alg traverseGroup(g)
    input array V, integer N, n group g
    output none
  1. for i <- 0 to n-1
      if(V[i].group = g)
        visit(V[i].elem)
  2. return
```

<em>삭제</em>

- 지정된 그룹의 모든 멤버를 삭제

```
  Alg removeGroup(g)
    input array V, integer N, n ,group g
    output none
  1. i <- 0
  2. while(i<n)
        if(V[i].group = g)
            remove(i)
        else
            i <- i+1
  3. return
```

## <em>설계 방안: 연결리스트 이용</em>

- 리스트를 elem 및 group 필드로 구성된 레코드 노드의 이중연결리스트를 이용하여 구현
- 장점 : 기억장소 사용 최소화

<em> 초기화 </em>

- 초기에는 각 그룹에 아무 노드도 없다

```
  Alg initGroup()
    input none
    output an empty doubly linked list with header H and trailer T
  1. H <- getnode()
  2. T <- getnode()
  3. H.next <- T
  4. T.prev <- H
  5. n <- 0
  6. return
```

<em>순회</em>

- 지정된 그룹의 모든 멤버들을 방문

```
  Alg traverseGroup(g,H,T)
    input a doubly linked list with header H and trailer T, group g
    output none
  1. p <- H.next
  2. while(p=/T)
        if(p.group = g)
            visit(p.elem)
        p <- p.next
  3. return
```

<em>삭제</em>

- 지정된 그룹의 모든 멤버들을 삭제

```
  Alg removeGroup(g)
    input a doubly linked list with header H and trailer T, group g
    output none
  1. p <- H.next
  2. while(p=/T)
        pnext <- p.next   {save next} // p노드를 삭제하기전에 다음을 저장
        if (p.group = g)
          removeNode(p)
          n <- n-1
        p <- pnext      {restore next} // 저장해뒀던 다음을 p에 대입
  3. return
```

## <em>설계 방안: 부리스트들의 리스트 사용</em>

- 그룹을 표현하기 위해, 그룹의 리스트를 사용하며, 각 그룹은 다시 원소들의 부리스트로 구성
- 그룹별로 리스트를 나누고, 각 리스트에 부리스트를 사용하여 설계
- 장점 : 특정그룹 관련 작업 격리 처리 가능

## <em>설계 방안: 2D 배열 이용</em>

- M x N 배열을 사용하여, 리스트는 각 그룹을 나타내는 행을, 부리스트는 각 행의 원소들을 이용하여 구현, M은 그룹의 개수, N은 각 원소의 최대 수용가능한 개수
- 단점 : 열의 크기 N이 최대 그룹의 크기를 커버해야 하므로 기억장소 낭비의 우려

<em>초기화</em>

- 초기에는 각 그룹에 아무 멤버도 없다

```
  Alg initGroup()
    input array V, n integer N, M
    output array n of size M
  1. for i <- 0 to M-1
        n[i] <- 0
  2. return
```

<em>순회</em>

- 지정된 그룹의 모든 멤버들을 방문

```
  Alg traverseGroup(g)
    input array V, n, integer N, group g
    output none
  1. for j <- 0 to n[g]-1
        visit(V[g,j])
  2.return
```

<em>삭제</em>

- 지정된 그룹의 모든 멤버들을 삭제

```
  Alg removeGroup(g)
    input array V, n, integer N, group g
    output none
  1. n[g] <- 0
  2. return
```

## <em>설계 방안: 연결리스트의 배열 이용</em>

- 리스트는 헤더 및 트레일러 주소를 저장하기 위한 두개의 1D 배열로, 부리스트는 각 그룹에 대한 이중연결리스트로 구현
  - 두 개의 1D 배열을 한 개의 2D 배열로 통합 가능
- 장점 : 기억장소 사용 최소화

<em>초기화</em>

```
  Alg initGroup()
    input array H,T,integer M
    output array H,T of pointers, each to headers and trailers of empty doubly linked lists
  1. for i <- 0 to M-1
        h <- getnode()
        t <- getnode()
        h.next <- t
        t.prev <- h
        H[i] <- h
        T[i] <- t
  2. return
```

<em>순회</em>

- 지정된 그룹의 모든 멤버들을 방문

```
  Alg traverseGroup(g)
    input array H,T,group g
    output none
  1. p <- H[g].next
  2. while(p =/ T[g])
        visit(p.elem)
        p <- p.next
  3. return
```

<em>삽입</em>

- 지정된 그룹의 지정된위치(여기서는 맨 앞)에 원소 삽입

```
  Alg addGroupFirst(g,e)
    input array H,T group g, element e
    output none
  1. H[g].addFirst(e)
  2. return
```

<em>삭제</em>

- 지정된 그룹의 모든 멤버들을 삭제

```
  Alg removeGroup(g)
    input array H,T group g
    output none
  1. removeAll(H[g],T[g]) {exercise}
  2. return
```

## <em>리스트 확장 : 공유</em>

- 문제상황
  - 데이터 원소들이 상이한 그룹에 의해 공유됨
- 전제
  - 각 관련 그룹에게 공유 데이터원소를 복제하는 것은 시간과 기억장소가 낭비되므로 허용하지 않음
- 예시
  - Student A : DS, OS
  - Student B : DB
  - Student C : OS, DB, MM
  - 학생 A의 OS와 학생 C의 OS가 겹침

## <em>설계 방안 : 공유</em>

- A. 레코드의 리스트 사용
  - 배열을 이용한 구현
  - 연결리스트를 이용한 구현
- B. 포인터의 리스트 사용
  - 배열을 이용한 구현
  - 연결리스트를 이용한 구현
- C. 다중리스트 사용
  - 2D 배열 구현
  - 다중 연결리스트를 이용한 구현

## <em>설계 방안 A: 레코드들의 리스트 사용</em>

- 앞서의 그룹을 표현하는 설계 방안 A와 동일
- 공유를 표현하기 위해, elem 및 group 필드로 구성된 레코드의 리스트를 사용
- 단점 : 특정원소 및 특정그룹 관련 작업 모두에 전체 레코드 순회 필요
  - 각각 O(n)시간 소요

<em>설계 방안 A: 배열 이용</em>

- 리스트를 elem 및 group 필드로 구성된 레코드의 1D 배열로 구현
- 장점 : 기억장소 낭비 없음

<em>설계 방안 A: 연결리스트 이용</em>

- 리스트를 elem 및 group 필드로 구성된 레코드 노드의 이중연결리스트로 구현
- 장점 : 기억장소 낭비 최소화

## <em>설계 방안 B: 포인터의 리스트 사용</em>

- 공유를 표현하기 위해, 원소들을 별도의 메모리에 저장하고 이들에 대한 참조를 포인터를 통해 수행
- 장점 : 단순, 기억장소 사용 최소화
- 단점 : 특정원소 관련작업의 격리 처리 불가

## <em>설계 방안 C: 다중리스트 사용</em>

- 공유를 표현하기 위해, 원소들의 리스트와 그룹들의 리스트가 상호 교차하는 형태의 다중리스트를 사용
- 교차점 서브리스트는 관련성 여부를 표현
- 장점 : 특정원소 및 특정그룹 관련 작업 모두 격리 처리 가능

<em>설계 방안 C: 2D배열 이용</em>

- 행과 열이 각각 원소와 그룹을 나타내는 2D논리배열이용
- 단점 : 원소-그룹 간 관계가 희소한 경우, 기억장소 낭비

<em>설계 방안 C: 다중연결리스트 이용</em>

- 다중연결리스트 구현
  - 두 개의 배열을 이용하여 원소 및 그룹 리스트를 각각 구현
  - 상호교차하는 원형 헤더 연결리스트들을 이용하여 (원소,그룹)쌍의 부리스트들을 구현
    - 헤더 외에 트레일러도 이용하거나, 또는 이중 연결리스트 이용가능
- 장점 : 기억장소 낭비 최소화
- 교차점 노드의 원소 및 그룹 정보는 해당 부리스트의 링크를 추적하여 헤더에서 구하도록 구현가능
  - 또는 각 교차점 노드에 원소 및 그룹 헤더로 직행하는 포인터들을 추가
