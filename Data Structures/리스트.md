## <em>추상자료형(ADT)</em>

- 추상자료형(abstract data type,ADT)
  - 데이터구조의 추상형
- ADT는 다음을 명세해야한다
  - 저장된 데이터
  - 데이터에 대한 작업들
  - 작업중 발생 가능한 에러 상황들

## <em>리스트 ADT</em>

- 연속적인 임의 개체들을 모델링
- 원소(element)에 대한 접근 도구
  - 순위(rank)

## <em>리스트 ADT method</em>

- 원소는 순위, 즉 그 원소의 앞의 원소 개수를 특정함으로써 원소에 접근가능
- 일반 메소드
  - boolean isEmpty()
  - integer size()
  - iterator elements()
- 접근 메소드
  - element get(r)
- 갱신 메소드
  - element set(r,e)
  - add(r,e)
    - addFirst(e)
    - addLast(e)
  - element remove(r)
    - removeFirst()
    - removeLast()

## <em>예외</em>

- 실행 불가능한 작업 때문에 예외를 발령한다(throw)
- 발령 가능한 예외들
  - invalidRankException()
  - fullListException()
  - emptyListException()

## <em>배열 초기화</em>

- 초기에는 아무 원소도 없음
- O(1) 시간 소요

```
    Alg initialize()
        input array V, integer N, n
        output an empty array V of size n
    1. n <- 0
    2. return
```

## <em>배열 순회</em>

- 작업 traverse는 array의 모든 원소를 방문
- O(n)

```
    Alg traverse()
        input array V, integer N,n
        output none
    1. for r <- 0 to n-1
        visit(V[r])
    2. return
```

## <em>배열 삽입</em>

- add(r,e)에서는 r 순위로 새 원소 e가 들어갈 자리를 만들기 위해 V[n-1]부터 V[r]까지 n-r개의 원소들을 순방향(shift forward)으로 이동
- 최악의 경우(r=0)
  - O(n)

```
    Alg add(r,e)
        input array V, integer N, n, rank r, element e
        output none
    1. if(n = N) // 배열의 원소가 전부 있을경우
        fullListException()
    2. if((r<0) || (r>n)) // 삽입 위치가 0보다 작거나 n보다 큰경우
        invalidRankException()
    3. for i<-n-1 down to r
        V[i+1] <- V[i]
    4. V[r] <- e
    5. n <- n+1
    6. return
```

## <em>배열 삭제</em>

- remove(r)에서는, 삭제된 원소에 의해 빈자리를 채우기 위해 V[r+1]부터 V[n-1]까지 n-r-1개의 원소들을 역방향(shift backward)으로 이동
- 최악의 경우(r=0)
  - O(n)

```
    Alg remove(r)
        input array V, integer N, n, rank r
        output element e
    1. if((r<0) || (r>n-1))
        invalidRankException()
    2. e <- V[r]
    3. for i <- r+1 to n-1
        V[i-1] <- V[i]
    4. n <- n-1
    5. return e
```

## <em>연결리스트를 이용하여 ADT 구현</em>

- 단일연결리스트 또는 , 이중연결리스트를 사용

## <em>단일연결리스트</em>

- singly linked list
  - 연속 노드로 구성된 구체적인 데이터구조
  - 현재 가리키고 있는 노드 앞의 정보를 가리키기 어려움(데이터 삭제시 불편)
- 각 노드의 저장 내용
  - 원소(element)
  - 다음 노드를 가리키는 링크(link)

## <em>이중연결리스트</em>

- doubly linked list
  - 리스트 ADT를 자연스럽게 구현가능
  - 접근성 및 조작성이 좋음
- 각 노드의 필드
  - 원소
  - 이전 노드를 가리키는 링크
  - 다음 노드를 가리키는 링크
- 특별 헤더 및 트레일러 노드

## <em>이중연결리스트를 이용한 구현</em>

- get(r),set(r)구현
  - O(n)시간에 지정된 순위 r의 원소를 반환 또는 저장
- 연결리스트에서 순위는 1에서 출발로 전제

```
  Alg get(r)
    input a doubly linked list with header H and trailer T, rank r
    output element

  1. if((r<1)||(r>n))
        invalidRankException()
  2. p <- H
  3. for i <- 1 to r
        p <- p.next
  4. return p.elem
```

```
  Alg set(r,e)
    input a doubly linked list with header H and trailer T, rank r, element e
    output element

  1. if((r<1)||(r>n))
        invalidRankException()
  2. p<-H
  3. for i<- 1 to r
        p<-p.next
  4. p.elem <- e
  5. return e
```

- header와 trailer는 직접 사용하지 않고 동일한 포인터를 만들어서 사용함

## <em>초기화</em>

- 초기에는 아무 노드도 없다
- O(1) 시간소요

```
  Alg initialize()
    input none
    output an empty doubly linked list with header  H and trailer T
  1. H <- getnode() // malloc한 주소값 대입
  2. T <- getnode()
  3. H.next <- T
  4. T.prev <- H
  5. n <- 0       {optional}
  6. return
```

## <em>순회</em>

- 연결리스트의 모든 원소들을 방문
- O(n) 시간소요

```
  Alg traverse()
    input a doubly linked list with header H and trailer T
    output none
  1. p <- H.next
  2. while( p =/ T) // trailer를 만날때 까지
      visit(p.elem)
      p <- p.next
  3. return
```

## <em>삽입</em>

- 이중연결리스트의 지정된 순위 r에 원소 e 삽입
- O(n) 시간소요
- add(r,X) // r =3

```
  Alg add(3,X)
    input a doubly linked list with header H and trailer T, rank r, element e
    output none
  1. if((r<1) || (r>n))
      invalidRankException()
  2. p <- H
  3. for i <- 1 to r // r = 3
        p <- p.next
  4. addNodeBefore(p,e)
  5. n <- n+1         {optional}
  6. return

  Alg addNodeBefore(p,e)
    input a doubly linked list with header H and trailer T, node p, element e
  1. q <- getnode()
  2. q.element <- e  // e = x
  3. q.prev <- p.prev // 삽입하려는 노드의 prev, next먼저 연결
  4. q.next <- p
  5. (p.prev).next <- q
  6. p.prev <- q
  7. return
```

## <em>삭제</em>

- 이중연결리스트의 지정된 순위 r에 원소 e 삭제
- O(n) 시간소요
- remove(r) // r=3

```
  Alg remove(r)
    input a doubly linked list with header H and trailer T, rank r
    output element
  1. if((r<1) || (r>n))
        invalidRankException()
  2. p <- H
  3. for i <- 1 to r
        p<- p.next
  4. e <- removeNode(p)
  5. n <- n-1     {optional}
  6. return e

  Alg removeNode(p)
    input a doubly linked list with header H and trailer T, node p
    output element
  1. e <- p.elem
  2. (p.prev).next <- p.next
  3. (p.next).prev <- p.prev
  4. putnode(p)     {reuse}
  5. return e
```

## <em>단일연결리스트 삽입삭제</em>

- add(), remove()할 이전 노드 pprev를 따로 저장해야 함

## <em> 성능 </em>

- 이중연결리스트를 이용한 리스트ADT를 구현한 경우
  - 연결리스트의 각 원소에 사용되는 기억장소 O(1)
  - n개의 원소로 구성된 연결리스트에 의해 사용되는 기억장소 O(n)
  - size, isEmpty O(1)
  - get,set,add,remove O(n)
  - addFirst, addLast, removeFirst, removeLast O(1)

## <em> 성능요약 </em>

| 작업                 | 배열 | 연결리스트 |
| -------------------- | :--: | ---------: |
| size, isEmpty        |  1   |          1 |
| get,set              |  1   |          n |
| add,remove           |  n   |          n |
| addFirst,removeFirst |  n   |          1 |
| addLast,removeLast   |  1   |          1 |

- Header와 trailer가 있기 때문에 1이 나올 수 있음
