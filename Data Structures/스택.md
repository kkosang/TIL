## <em> 스택 ADT </em>

- 스택 ADT는 임의의 개체를 저장
- 삽입과 삭제는 <em>후입선출</em>(Last-In First-Out,LIFO)순서를 따름
- 삽입과 삭제는 스택의 <em>top</em>이라 불리는 위치에서 수행

## <em> 스택 ADT 메소드 </em>

- 주요 스택 메소드

  - push(e)
    - 원소를 삽입
  - element pop()
    - 가장 최근에 삽입된 원소를 삭제하여 반환

- 보조 스택 메소드
  - element top()
    - 가장 최근에 삽입된 원소를(삭제하지 않고) 반환
  - integer size()
    - 저장된 원소의 수를 반환
  - boolean isEmpty()
    - 아무원소도 저장되어 있지 않고 비어 있는지 여부를 반환
  - boolean isFull()
    - 만원 스택인지 여부를 반환
  - iterator elements()
    - 스택 원소 전체를 반환
- 예외
  - emptyStackException()
    - 비어 있는 스택에서 삭제나 top을 시도할 경우 발령
  - fullStackException()
    - 만원 스택에서 삽입을 시도할 경우 발령

## <em> 스택 응용 </em>

- 직접 응용
  - 웹브라우저에서 방문한 웹페이지들의 기록
  - 문서편집기에서 되돌리기 기록
  - 윈도 운영체제에서 겹쳐진 윈도우들
  - C++ 실행환경 또는 자바가상기계에서 메소드의 연쇄적인 호출
  - 재귀의 구현
- 간접 응용
  - 알고리즘 수행을 위한 보조 데이터구조
  - 다른 데이터구조를 구성하는 요소

## <em> 배열에 기초한 스택 </em>

- 크기 N의 배열을 사용
- 원소들을 배열의 왼쪽에서 오른쪽으로 추가
  - 마지막원소의 자리(top)를 기억하면서 그 자리에서 삽입삭제
- 변수 t를 사용하여 top원소의 첨자를 관리

## <em> 초기화 </em>

- 초기에는 스택에 아무 원소도 없다

```
    // O(1)
    Alg initStack()
        input stack S, size N, top t
        output an empty stack S
    1. t <- 1 // top은 현재 마지막원소의 위치를 가리키고 있음
        cf) t <- top은 다음에 추가되어야 하는 위치를 가리킴
    2. return
    // top에따라 push,pop을 다르게 구현
```

## <em> 삽입 </em>

- 스택이 만원인 경우, push작업은 fullStackException을 발령
  - 배열에 기초한 구현의 한계
  - 구현현상의 오류(배열)일 뿐 스택 ADT 취급상 논리적 오류는 아님

```
    // O(1)
    Alg push(e)
        input stack S, size N, top t, element e
        output none
    1. if ( t = N-1 ) // t = -1
            fullStackException()
    2. t <- t + 1
    3. S[t] <- e
    4. return
```

## <em> 삭제 </em>

- 스택이 빈 경우, pop작업은 emptyStackException을 발령
  - 스택 ADT 취급 상 논리적 오류

```
    // O(1)
    Alg pop()
        input stack S, size N, top t
        output element;
    1. if(isEmpty())
            emptyStackException()
    2. t <- t-1
    3. return S[t+1]
```

## <em> 보조 메소드 </em>

- boolean is Empty()
  - 스택이 비어 있는지 여부를 반환
- integer size()
  - 스택에 저장된 원소의 수를 반환
- element top()
  - 가장 최근에 삽입된 원소를 삭제하지 않고 반환

```
    // O(1)
    Alg isEmpty()
    1. return t = -1 // t == -1

    Alg size()
    1. return t+1

    Alg top()
    1. if(isEmpty())
        emptyStackException()
    2. return S[t]
```

## <em> 성능과 제약 </em>

- 성능
  - 스택의 원소 개수를 n이라 하면,
  - 기억장소 사용
    - O(n)
  - 각 작업의 실행시간
    - O(1)
- 제약
  - 스택의 최대 크기를 예측할 수 있어야 하며 이 값은 실행중 변경할 수 없다 (예외 : 동적할당)
  - 만원인 스택에 새로운 원소를 push 시도할 경우 구현상의 오류를 일으킨다

## <em> 연결리스트에 기초한 스택 </em>

- 단일연결리스트를 사용하여 스택 구현 가능
  - 삽입과 삭제가 특정위치에서만 수행되므로, 헤더노드는 불필요
- top 원소를 연결리스트의 첫 노드에 저장하고 이곳을 t로 가리키게 한다
- 기억장소
  - O(n)
- 스택 ADT의 각 작업
  - O(1)

## <em> 초기화 </em>

- 초기에는 아무 노드도 없다

```
    // O(1)
    Alg initStack()
        input top t
        output an empty stack with top t
    1. t <- NULL
    2. return
```

## <em> 삽입 </em>

```
    // O(1)
    Alg push(e)
        input top t, element e
        output none
    1. p <- getnode()
    2. p.elem <- e
    3. p.next <- t
    4. t <- p   // c로 구현시 t가 변하니까 ** 사용하거나 반환값을 받음
    5. return
```

## <em> 삭제 </em>

```
    // O(1)
    Alg isEmpty()
        input top t
        output boolean
    1. return t = NULL

    // O(1)
    Alg pop()
        input top t
        output element
    1. if(isEmpty())
            emptyStackException()
    2. e <- t.elem
    3. p <- t
    4. t <- t.next
    5. putnode(p)
    6. return e
```
